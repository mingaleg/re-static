###############################################################################
# MyPy Plugin Integration Tests for re-static
#
# These tests use pytest-mypy-plugins to verify type checking behavior.
# Run with: uv run pytest tests/test_mypy_plugin_integration.yml -v
#
# Test format documentation:
# https://github.com/typeddjango/pytest-mypy-plugins
###############################################################################

###############################################################################
# BASIC FUNCTIONALITY - Required Groups
###############################################################################

- case: basic_required_groups
  mypy_config: &mypy_config |
    [mypy]
    plugins = re_static.mypy_plugin.plugin
  main: |
    from re_static import StaticRegex

    class EmailRegex(StaticRegex):
        REGEX = r"(?P<username>[a-zA-Z0-9._%+-]+)@(?P<domain>[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})"

    result = EmailRegex.match("test@example.com")
    if result:
        username: str = result.username
        domain: str = result.domain
        reveal_type(result.username)  # N: Revealed type is "builtins.str"
        reveal_type(result.domain)    # N: Revealed type is "builtins.str"

- case: required_group_single
  mypy_config: *mypy_config
  main: |
    from re_static import StaticRegex

    class DigitsRegex(StaticRegex):
        REGEX = r"(?P<digits>\d+)"

    result = DigitsRegex.match("123")
    if result:
        digits: str = result.digits
        reveal_type(result.digits)  # N: Revealed type is "builtins.str"

###############################################################################
# OPTIONAL GROUPS - str | None typing
###############################################################################

- case: optional_group_correct_type
  mypy_config: *mypy_config
  main: |
    from re_static import StaticRegex

    class OptionalRegex(StaticRegex):
        REGEX = r"(?P<required>[a-z]+)(?P<optional>[0-9]+)?"

    result = OptionalRegex.match("hello")
    if result:
        required: str = result.required
        optional: str | None = result.optional
        reveal_type(result.required)  # N: Revealed type is "builtins.str"
        reveal_type(result.optional)  # N: Revealed type is "builtins.str | None"

- case: optional_group_cannot_assign_to_str
  mypy_config: *mypy_config
  main: |
    from re_static import StaticRegex

    class OptionalRegex(StaticRegex):
        REGEX = r"(?P<required>[a-z]+)(?P<optional>[0-9]+)?"

    result = OptionalRegex.match("hello")
    if result:
        required: str = result.required  # OK
        optional: str = result.optional  # E: Incompatible types in assignment (expression has type "str | None", variable has type "str")  [assignment]

- case: optional_group_cannot_call_methods_without_check
  mypy_config: *mypy_config
  main: |
    from re_static import StaticRegex

    class OptionalRegex(StaticRegex):
        REGEX = r"(?P<required>[a-z]+)(?P<optional>[0-9]+)?"

    result = OptionalRegex.match("hello")
    if result:
        result.optional.upper()  # E: Item "None" of "str | None" has no attribute "upper"  [union-attr]

- case: optional_group_with_narrowing
  mypy_config: *mypy_config
  main: |
    from re_static import StaticRegex

    class OptionalRegex(StaticRegex):
        REGEX = r"(?P<required>[a-z]+)(?P<optional>[0-9]+)?"

    result = OptionalRegex.match("hello123")
    if result:
        if result.optional is not None:
            # After narrowing, should be str
            upper: str = result.optional.upper()
            reveal_type(result.optional)  # N: Revealed type is "builtins.str"

- case: optional_group_with_or_default
  mypy_config: *mypy_config
  main: |
    from re_static import StaticRegex

    class OptionalRegex(StaticRegex):
        REGEX = r"(?P<required>[a-z]+)(?P<optional>[0-9]+)?"

    result = OptionalRegex.match("hello")
    if result:
        # Using 'or' operator for default value
        value: str = result.optional or "default"

###############################################################################
# MATCH RESULT TYPING - Return types of match methods
###############################################################################

- case: match_returns_optional_instance
  mypy_config: *mypy_config
  main: |
    from re_static import StaticRegex

    class TestRegex(StaticRegex):
        REGEX = r"(?P<test>\d+)"

    result = TestRegex.match("123")
    reveal_type(result)  # N: Revealed type is "main.TestRegex | None"

- case: search_returns_optional_instance
  mypy_config: *mypy_config
  main: |
    from re_static import StaticRegex

    class TestRegex(StaticRegex):
        REGEX = r"(?P<test>\d+)"

    result = TestRegex.search("abc123")
    reveal_type(result)  # N: Revealed type is "main.TestRegex | None"

- case: fullmatch_returns_optional_instance
  mypy_config: *mypy_config
  main: |
    from re_static import StaticRegex

    class TestRegex(StaticRegex):
        REGEX = r"(?P<test>\d+)"

    result = TestRegex.fullmatch("123")
    reveal_type(result)  # N: Revealed type is "main.TestRegex | None"

- case: findall_returns_list
  mypy_config: *mypy_config
  main: |
    from re_static import StaticRegex

    class TestRegex(StaticRegex):
        REGEX = r"(?P<test>\d+)"

    results = TestRegex.findall("123 456 789")
    reveal_type(results)  # N: Revealed type is "builtins.list[main.TestRegex]"

- case: finditer_returns_iterator
  mypy_config: *mypy_config
  main: |
    from re_static import StaticRegex

    class TestRegex(StaticRegex):
        REGEX = r"(?P<test>\d+)"

    results = TestRegex.finditer("123 456")
    reveal_type(results)  # N: Revealed type is "typing.Iterator[main.TestRegex]"

###############################################################################
# ERROR CASES - Wrong return types
###############################################################################

- case: wrong_return_type_not_optional
  mypy_config: *mypy_config
  main: |
    from re_static import StaticRegex

    class EmailRegex(StaticRegex):
        REGEX = r"(?P<username>[a-zA-Z0-9._%+-]+)@(?P<domain>[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})"

    def get_email() -> EmailRegex:
        return EmailRegex.match("test@example.com")  # E: Incompatible return value type (got "EmailRegex | None", expected "EmailRegex")  [return-value]

- case: accessing_attribute_on_none
  mypy_config: *mypy_config
  main: |
    from re_static import StaticRegex

    class EmailRegex(StaticRegex):
        REGEX = r"(?P<username>[a-zA-Z0-9._%+-]+)@(?P<domain>[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})"

    result = EmailRegex.match("not an email")
    result.username  # E: Item "None" of "EmailRegex | None" has no attribute "username"  [union-attr]

- case: wrong_list_type_annotation
  mypy_config: *mypy_config
  main: |
    from re_static import StaticRegex

    class DigitsRegex(StaticRegex):
        REGEX = r"(?P<digits>\d+)"

    # findall returns list[DigitsRegex], not list[str]
    results: list[str] = DigitsRegex.findall("123 456")  # E: Incompatible types in assignment (expression has type "list[DigitsRegex]", variable has type "list[str]")  [assignment]

- case: wrong_iterator_type_annotation
  mypy_config: *mypy_config
  main: |
    from re_static import StaticRegex
    from collections.abc import Iterator

    class DigitsRegex(StaticRegex):
        REGEX = r"(?P<digits>\d+)"

    # finditer returns Iterator[DigitsRegex], not Iterator[str]
    results: Iterator[str] = DigitsRegex.finditer("123")  # E: Incompatible types in assignment (expression has type "Iterator[DigitsRegex]", variable has type "Iterator[str]")  [assignment]

- case: assigning_instance_to_wrong_type
  mypy_config: *mypy_config
  main: |
    from re_static import StaticRegex

    class EmailRegex(StaticRegex):
        REGEX = r"(?P<username>[a-zA-Z0-9._%+-]+)@(?P<domain>[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})"

    result = EmailRegex.match("test@example.com")
    if result:
        value: str = result  # E: Incompatible types in assignment (expression has type "EmailRegex", variable has type "str")  [assignment]

- case: invalid_regex_pattern_error
  mypy_config: *mypy_config
  main: |
    from re_static import StaticRegex

    class BadRegex(StaticRegex):  # E: Invalid regex pattern: unterminated character set at position 8  [misc]
        REGEX = r"(?P<bad>[unclosed"

###############################################################################
# METHOD CALL ERRORS
###############################################################################

- case: match_requires_string_argument
  mypy_config: *mypy_config
  main: |
    from re_static import StaticRegex

    class TestRegex(StaticRegex):
        REGEX = r"(?P<test>\d+)"

    TestRegex.match()  # E: Missing positional argument "string" in call to "match" of "StaticRegex"  [call-arg]

- case: match_wrong_argument_type
  mypy_config: *mypy_config
  main: |
    from re_static import StaticRegex

    class TestRegex(StaticRegex):
        REGEX = r"(?P<test>\d+)"

    TestRegex.match(123)  # E: Argument 1 to "match" of "StaticRegex" has incompatible type "int"; expected "str"  [arg-type]

- case: optional_in_len_without_check
  mypy_config: *mypy_config
  main: |
    from re_static import StaticRegex

    class OptionalRegex(StaticRegex):
        REGEX = r"(?P<required>[a-z]+)(?P<optional>[0-9]+)?"

    result = OptionalRegex.match("hello")
    if result:
        length = len(result.optional)  # E: Argument 1 to "len" has incompatible type "str | None"; expected "Sized"  [arg-type]

###############################################################################
# COMPLEX PATTERNS
###############################################################################

- case: multiple_optional_groups
  mypy_config: *mypy_config
  main: |
    from re_static import StaticRegex

    class MultiOptional(StaticRegex):
        REGEX = r"(?P<first>\w+)(?P<second>\s+\w+)?(?P<third>\s+\w+)?"

    result = MultiOptional.match("hello world")
    if result:
        reveal_type(result.first)   # N: Revealed type is "builtins.str"
        reveal_type(result.second)  # N: Revealed type is "builtins.str | None"
        reveal_type(result.third)   # N: Revealed type is "builtins.str | None"

- case: complex_log_line_regex
  mypy_config: *mypy_config
  main: |
    from re_static import StaticRegex

    class LogLineRegex(StaticRegex):
        REGEX = r"(?P<timestamp>\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}) \[(?P<level>\w+)\] (?P<message>.*?)(?P<error_code> \(code: \d+\))?"

    log = "2023-12-01 10:30:15 [ERROR] Connection failed (code: 500)"
    result = LogLineRegex.match(log)
    if result:
        timestamp: str = result.timestamp
        level: str = result.level
        message: str = result.message
        error_code: str | None = result.error_code
        reveal_type(result.error_code)  # N: Revealed type is "builtins.str | None"

###############################################################################
# MULTIPLE REGEX CLASSES
###############################################################################

- case: multiple_classes_in_same_scope
  mypy_config: *mypy_config
  main: |
    from re_static import StaticRegex

    class EmailRegex(StaticRegex):
        REGEX = r"(?P<username>[a-zA-Z0-9._%+-]+)@(?P<domain>[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})"

    class DigitsRegex(StaticRegex):
        REGEX = r"(?P<digits>\d+)"

    email = EmailRegex.match("test@example.com")
    digits = DigitsRegex.match("123")

    if email and digits:
        # Each should have their own group attributes
        username: str = email.username
        num: str = digits.digits
        reveal_type(email.username)  # N: Revealed type is "builtins.str"
        reveal_type(digits.digits)   # N: Revealed type is "builtins.str"

###############################################################################
# EDGE CASES
###############################################################################

- case: subclass_inherits_regex_groups
  mypy_config: *mypy_config
  main: |
    from re_static import StaticRegex

    class EmailRegex(StaticRegex):
        REGEX = r"(?P<username>[a-zA-Z0-9._%+-]+)@(?P<domain>[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})"

    # Subclass that inherits the REGEX pattern
    class MyEmailRegex(EmailRegex):
        pass

    result = MyEmailRegex.match("test@example.com")
    if result:
        # Should inherit the same group types from parent
        username: str = result.username
        domain: str = result.domain
        reveal_type(result.username)  # N: Revealed type is "builtins.str"
        reveal_type(result.domain)    # N: Revealed type is "builtins.str"

- case: regex_with_no_named_groups
  mypy_config: *mypy_config
  main: |
    from re_static import StaticRegex

    class NoGroupsRegex(StaticRegex):
        REGEX = r"\d+"

    result = NoGroupsRegex.match("123")
    if result:
        # Valid instance, just no group attributes to access
        reveal_type(result)  # N: Revealed type is "main.NoGroupsRegex"

- case: list_comprehension_with_groups
  mypy_config: *mypy_config
  main: |
    from re_static import StaticRegex

    class DigitsRegex(StaticRegex):
        REGEX = r"(?P<digits>\d+)"

    text = "123 456 789"
    results = DigitsRegex.findall(text)

    digit_strings: list[str] = [r.digits for r in results]
    digit_ints: list[int] = [int(r.digits) for r in results]

- case: walrus_operator_with_match
  mypy_config: *mypy_config
  main: |
    from re_static import StaticRegex

    class EmailRegex(StaticRegex):
        REGEX = r"(?P<username>[a-zA-Z0-9._%+-]+)@(?P<domain>[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})"

    text = "test@example.com"
    if (match := EmailRegex.match(text)):
        username: str = match.username
        reveal_type(match.username)  # N: Revealed type is "builtins.str"

- case: chained_string_methods
  mypy_config: *mypy_config
  main: |
    from re_static import StaticRegex

    class EmailRegex(StaticRegex):
        REGEX = r"(?P<username>[a-zA-Z0-9._%+-]+)@(?P<domain>[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})"

    result = EmailRegex.match("test@example.com")
    if result:
        upper_username: str = result.username.upper()
        domain_len: int = len(result.domain)

- case: passing_groups_to_functions
  mypy_config: *mypy_config
  main: |
    from re_static import StaticRegex

    def process_email(username: str, domain: str) -> str:
        return f"{username}@{domain}"

    class EmailRegex(StaticRegex):
        REGEX = r"(?P<username>[a-zA-Z0-9._%+-]+)@(?P<domain>[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})"

    result = EmailRegex.match("test@example.com")
    if result:
        email: str = process_email(result.username, result.domain)

- case: pos_and_endpos_parameters
  mypy_config: *mypy_config
  main: |
    from re_static import StaticRegex

    class DigitsRegex(StaticRegex):
        REGEX = r"(?P<digits>\d+)"

    result1 = DigitsRegex.match("abc123", pos=3)
    result2 = DigitsRegex.match("123456", endpos=3)
    result3 = DigitsRegex.match("abc123def", pos=3, endpos=6)

    if result1:
        digits: str = result1.digits

###############################################################################
# SAFETY TESTS - Ensuring the plugin doesn't interfere with unrelated code
###############################################################################

- case: class_with_regex_but_no_inheritance
  mypy_config: *mypy_config
  main: |
    from re_static import StaticRegex

    # This has REGEX but doesn't inherit from StaticRegex
    # The plugin should ignore it completely
    class NotAStaticRegex:
        REGEX = r"(?P<username>\w+)@(?P<domain>\w+)"

        def __init__(self) -> None:
            pass

    instance = NotAStaticRegex()
    # Plugin should NOT add username/domain attributes
    instance.username  # E: "NotAStaticRegex" has no attribute "username"  [attr-defined]

- case: unrelated_class_with_name_collision
  mypy_config: *mypy_config
  main: |
    from re_static import StaticRegex

    class EmailRegex(StaticRegex):
        REGEX = r"(?P<username>[a-zA-Z0-9._%+-]+)@(?P<domain>[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})"

    # Unrelated class with same attribute names as regex groups
    class Person:
        def __init__(self, username: str, domain: str) -> None:
            self.username = username
            self.domain = domain

    person = Person("john", "example.com")
    # Plugin should NOT interfere - normal mypy typing applies
    reveal_type(person.username)  # N: Revealed type is "builtins.str"
    reveal_type(person.domain)    # N: Revealed type is "builtins.str"

    # Type checking should work normally
    bad: int = person.username  # E: Incompatible types in assignment (expression has type "str", variable has type "int")  [assignment]

- case: staticregex_and_unrelated_class_coexist
  mypy_config: *mypy_config
  main: |
    from re_static import StaticRegex

    class DigitsRegex(StaticRegex):
        REGEX = r"(?P<digits>\d+)"

    class UnrelatedClass:
        digits: int  # Same name but different type

        def __init__(self, digits: int) -> None:
            self.digits = digits

    # Both should work correctly without interference
    regex_match = DigitsRegex.match("123")
    if regex_match:
        d1: str = regex_match.digits  # From StaticRegex - typed as str
        reveal_type(regex_match.digits)  # N: Revealed type is "builtins.str"

    obj = UnrelatedClass(42)
    d2: int = obj.digits  # From UnrelatedClass - typed as int
    reveal_type(obj.digits)  # N: Revealed type is "builtins.int"

- case: multiple_inheritance_non_staticregex_base
  mypy_config: *mypy_config
  main: |
    from re_static import StaticRegex

    class Mixin:
        def helper(self) -> str:
            return "helper"

    # Multiple inheritance with StaticRegex
    class EmailRegex(Mixin, StaticRegex):
        REGEX = r"(?P<username>[a-zA-Z0-9._%+-]+)@(?P<domain>[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})"

    result = EmailRegex.match("test@example.com")
    if result:
        # Should still get regex groups
        username: str = result.username
        # And mixin methods
        helper: str = result.helper()
        reveal_type(result.username)  # N: Revealed type is "builtins.str"

- case: independent_staticregex_class_ignored
  mypy_config: *mypy_config
  main: |
    from re_static import StaticRegex as RealStaticRegex

    # Someone independently defines their own StaticRegex class
    class StaticRegex:
        """A different StaticRegex (not from re_static)"""
        pass

    # Inherits from THEIR StaticRegex, not ours
    class TheirRegex(StaticRegex):
        REGEX = r"(?P<username>\w+)@(?P<domain>\w+)"

    # Plugin should NOT add username/domain to this class
    instance = TheirRegex()
    instance.username  # E: "TheirRegex" has no attribute "username"  [attr-defined]

    # Compare with the real StaticRegex - should work
    class OurRegex(RealStaticRegex):
        REGEX = r"(?P<username>\w+)"

    result = OurRegex.match("test")
    if result:
        reveal_type(result.username)  # N: Revealed type is "builtins.str"

- case: independent_staticregex_used_directly
  mypy_config: *mypy_config
  main: |
    from re_static import StaticRegex as RealStaticRegex

    # Someone defines their own StaticRegex and uses it directly (not via inheritance)
    class StaticRegex:
        REGEX = r"(?P<username>\w+)@(?P<domain>\w+)"

        def __init__(self) -> None:
            pass

    # Direct instantiation (not inheritance)
    instance = StaticRegex()
    reveal_type(instance)  # N: Revealed type is "main.StaticRegex"

    # Plugin should NOT add username/domain attributes
    instance.username  # E: "StaticRegex" has no attribute "username"  [attr-defined]
    instance.domain    # E: "StaticRegex" has no attribute "domain"  [attr-defined]

    # Setting attributes dynamically shouldn't confuse the plugin
    instance.REGEX = r"(?P<test>\d+)"
    instance.test  # E: "StaticRegex" has no attribute "test"  [attr-defined]

    # The real StaticRegex should still work
    class WorkingRegex(RealStaticRegex):
        REGEX = r"(?P<real_group>\w+)"

    result = WorkingRegex.match("test")
    if result:
        reveal_type(result.real_group)  # N: Revealed type is "builtins.str"

- case: two_staticregex_subclasses_same_group_names
  mypy_config: *mypy_config
  main: |
    from re_static import StaticRegex

    # Two different regex classes with same group names
    class EmailRegex(StaticRegex):
        REGEX = r"(?P<username>[a-zA-Z0-9._%+-]+)@(?P<domain>[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})"

    class URLRegex(StaticRegex):
        REGEX = r"(?P<protocol>https?)://(?P<domain>[a-zA-Z0-9.-]+)"

    # Both have 'domain' but should be independent
    email = EmailRegex.match("test@example.com")
    url = URLRegex.match("https://example.com")

    if email:
        # EmailRegex has username (str) and domain (str)
        u1: str = email.username
        d1: str = email.domain
        reveal_type(email.username)  # N: Revealed type is "builtins.str"
        reveal_type(email.domain)    # N: Revealed type is "builtins.str"

    if url:
        # URLRegex has protocol (str) and domain (str)
        # Should NOT have username
        p1: str = url.protocol
        d2: str = url.domain
        reveal_type(url.protocol)  # N: Revealed type is "builtins.str"
        reveal_type(url.domain)    # N: Revealed type is "builtins.str"
        url.username  # E: "URLRegex" has no attribute "username"  [attr-defined]
